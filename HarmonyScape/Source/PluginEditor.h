#pragma once

#include "JuceHeader.h"
#include "PluginProcessor.h"

//==============================================================================
/**
 * HarmonyScape plugin editor with basic UI controls
 */
class HarmonyScapeAudioProcessorEditor  : public juce::AudioProcessorEditor,
                                          private juce::Timer
{
public:
    HarmonyScapeAudioProcessorEditor (HarmonyScapeAudioProcessor&, juce::AudioProcessorValueTreeState&);
    ~HarmonyScapeAudioProcessorEditor() override;

    //==============================================================================
    void paint (juce::Graphics&) override;
    void resized() override;
    
    // Timer callback for updating the keyboard display
    void timerCallback() override;

private:
    // Reference to our processor
    HarmonyScapeAudioProcessor& audioProcessor;
    
    // Reference to parameter tree
    juce::AudioProcessorValueTreeState& valueTreeState;
    
    // UI Components - Keyboard display
    juce::MidiKeyboardComponent midiKeyboard;
    juce::Array<int> userNotes;     // Notes played by user
    juce::Array<int> generatedNotes; // Notes generated by chord engine
    
    // UI Components - Synth controls
    juce::ComboBox waveformCombo;
    juce::Slider volumeSlider;
    juce::Label waveformLabel;
    juce::Label volumeLabel;
    
    // UI Components - Main parameters
    juce::Slider chordDensitySlider;
    juce::Slider spatialWidthSlider;
    juce::Label chordDensityLabel;
    juce::Label spatialWidthLabel;
    
    // UI Components - ADSR controls
    juce::Slider attackSlider;
    juce::Slider decaySlider;
    juce::Slider sustainSlider;
    juce::Slider releaseSlider;
    juce::Label attackLabel;
    juce::Label decayLabel;
    juce::Label sustainLabel;
    juce::Label releaseLabel;
    
    // Parameter attachments
    std::unique_ptr<juce::AudioProcessorValueTreeState::SliderAttachment> chordDensityAttachment;
    std::unique_ptr<juce::AudioProcessorValueTreeState::SliderAttachment> spatialWidthAttachment;
    std::unique_ptr<juce::AudioProcessorValueTreeState::ComboBoxAttachment> waveformAttachment;
    std::unique_ptr<juce::AudioProcessorValueTreeState::SliderAttachment> volumeAttachment;
    std::unique_ptr<juce::AudioProcessorValueTreeState::SliderAttachment> attackAttachment;
    std::unique_ptr<juce::AudioProcessorValueTreeState::SliderAttachment> decayAttachment;
    std::unique_ptr<juce::AudioProcessorValueTreeState::SliderAttachment> sustainAttachment;
    std::unique_ptr<juce::AudioProcessorValueTreeState::SliderAttachment> releaseAttachment;
    
    // Custom MidiKeyboardComponent that shows different colors for user and generated notes
    class CustomMidiKeyboard : public juce::MidiKeyboardComponent
    {
    public:
        CustomMidiKeyboard(juce::MidiKeyboardState& state, juce::MidiKeyboardComponent::Orientation orientation)
            : juce::MidiKeyboardComponent(state, orientation)
        {
            this->setColour(juce::MidiKeyboardComponent::keyDownOverlayColourId, juce::Colours::blue);
        }
        
        void setUserNotes(const juce::Array<int>& notes) 
        { 
            userNotesList = notes; 
            repaint();
        }
        
        void setGeneratedNotes(const juce::Array<int>& notes) 
        { 
            generatedNotesList = notes; 
            repaint();
        }
        
    protected:
        void drawWhiteNote(int midiNoteNumber, juce::Graphics& g, juce::Rectangle<float> area, 
                           bool isDown, bool isOver, juce::Colour lineColour, juce::Colour textColour) override
        {
            // Choose color based on whether this is a user note or generated note
            juce::Colour fillColor = juce::Colours::white;
            
            if (isUserNote(midiNoteNumber))
                fillColor = juce::Colours::blue.withAlpha(0.7f);
            else if (isGeneratedNote(midiNoteNumber))
                fillColor = juce::Colours::green.withAlpha(0.7f);
            else if (isDown)
                fillColor = findColour(keyDownOverlayColourId);
            
            g.setColour(fillColor);
            g.fillRect(area);
            
            g.setColour(lineColour);
            g.drawRect(area);
        }
        
        void drawBlackNote(int midiNoteNumber, juce::Graphics& g, juce::Rectangle<float> area, 
                          bool isDown, bool isOver, juce::Colour noteFillColour) override
        {
            // Choose color based on whether this is a user note or generated note
            juce::Colour fillColor = noteFillColour;
            
            if (isUserNote(midiNoteNumber))
                fillColor = juce::Colours::blue.withAlpha(0.7f);
            else if (isGeneratedNote(midiNoteNumber))
                fillColor = juce::Colours::green.withAlpha(0.7f);
            else if (isDown)
                fillColor = findColour(keyDownOverlayColourId);
            
            g.setColour(fillColor);
            g.fillRect(area);
            
            g.setColour(juce::Colours::black);
            g.drawRect(area);
        }
        
    private:
        bool isUserNote(int midiNoteNumber) const
        {
            return userNotesList.contains(midiNoteNumber);
        }
        
        bool isGeneratedNote(int midiNoteNumber) const
        {
            return generatedNotesList.contains(midiNoteNumber) && !userNotesList.contains(midiNoteNumber);
        }
        
        juce::Array<int> userNotesList;
        juce::Array<int> generatedNotesList;
    };
    
    // Implement custom keyboard to show colored keys
    juce::MidiKeyboardState keyboardState;
    CustomMidiKeyboard customKeyboard;
    
    // ADSR Visualizer Component
    class ADSRVisualizer : public juce::Component
    {
    public:
        ADSRVisualizer() {}
        
        void setADSR(float a, float d, float s, float r)
        {
            attack = a;
            decay = d;
            sustain = s;
            release = r;
            repaint();
        }
        
        void paint(juce::Graphics& g) override
        {
            auto bounds = getLocalBounds().reduced(10);
            
            // Background
            g.setColour(juce::Colours::black.withAlpha(0.5f));
            g.fillRoundedRectangle(bounds.toFloat(), 5.0f);
            
            // Grid lines
            g.setColour(juce::Colours::grey.withAlpha(0.3f));
            const int gridLines = 4;
            for (int i = 1; i < gridLines; ++i)
            {
                float y = bounds.getY() + (bounds.getHeight() * i / gridLines);
                g.drawHorizontalLine(static_cast<int>(y), static_cast<float>(bounds.getX()), static_cast<float>(bounds.getRight()));
            }
            
            // Calculate ADSR curve points
            const float maxTime = 4.0f; // Max 4 seconds total time
            const float totalTime = attack + decay + release + 0.5f; // 0.5f for sustain display
            const float timeScale = bounds.getWidth() / std::max(totalTime, 1.0f);
            
            juce::Path envelope;
            
            // Start point
            float x = static_cast<float>(bounds.getX());
            float y = static_cast<float>(bounds.getBottom());
            envelope.startNewSubPath(x, y);
            
            // Attack point (peak)
            x += attack * timeScale;
            y = static_cast<float>(bounds.getY());
            envelope.lineTo(x, y);
            
            // Decay point (to sustain level)
            x += decay * timeScale;
            y = bounds.getY() + bounds.getHeight() * (1.0f - sustain);
            envelope.lineTo(x, y);
            
            // Sustain (hold for display)
            x += 0.5f * timeScale;
            envelope.lineTo(x, y);
            
            // Release point (back to zero)
            x += release * timeScale;
            y = static_cast<float>(bounds.getBottom());
            envelope.lineTo(x, y);
            
            // Draw the envelope curve
            g.setColour(juce::Colours::cyan);
            g.strokePath(envelope, juce::PathStrokeType(2.0f));
            
            // Draw control points as small circles
            g.setColour(juce::Colours::white);
            const float circleRadius = 4.0f;
            
            // Attack point
            x = bounds.getX() + attack * timeScale;
            y = static_cast<float>(bounds.getY());
            g.fillEllipse(x - circleRadius, y - circleRadius, circleRadius * 2, circleRadius * 2);
            
            // Decay/Sustain point
            x = bounds.getX() + (attack + decay) * timeScale;
            y = bounds.getY() + bounds.getHeight() * (1.0f - sustain);
            g.fillEllipse(x - circleRadius, y - circleRadius, circleRadius * 2, circleRadius * 2);
            
            // Release start point
            x = bounds.getX() + (attack + decay + 0.5f) * timeScale;
            g.fillEllipse(x - circleRadius, y - circleRadius, circleRadius * 2, circleRadius * 2);
            
            // Labels
            g.setColour(juce::Colours::lightgrey);
            g.setFont(10.0f);
            g.drawText("A", bounds.getX(), bounds.getBottom() + 2, 20, 12, juce::Justification::centred);
            g.drawText("D", bounds.getX() + attack * timeScale, bounds.getBottom() + 2, 20, 12, juce::Justification::centred);
            g.drawText("S", bounds.getX() + (attack + decay) * timeScale, bounds.getBottom() + 2, 20, 12, juce::Justification::centred);
            g.drawText("R", bounds.getX() + (attack + decay + 0.5f) * timeScale, bounds.getBottom() + 2, 20, 12, juce::Justification::centred);
        }
        
    private:
        float attack = 0.01f;
        float decay = 0.1f;
        float sustain = 0.7f;
        float release = 0.2f;
    };
    
    ADSRVisualizer adsrVisualizer;
    
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (HarmonyScapeAudioProcessorEditor)
}; 